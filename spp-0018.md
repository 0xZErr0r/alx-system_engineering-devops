## Preamble

```
SPP: 0018
Title: Versioning
Author: Smilepay
Status: Active
Created: 02-03-2022
Discussion: N/A
```

## Description
**Versioning (software versioning workflow)** <br />
Is an incremental value assigning process to software development done in a certain time that allows development teams to keep track of all the changes they make to the project code. 

This changes may include new functions, features, minor changes or bug fixes. Versioning can be an internal practice used to make it easier for developers to keep track of code evolution. 


During development, teams involved in the process may apply internal versioning numbers that can be incremented several times within a day. In contrast, the publicly released version usually does not change very often. For instance, the internal version number used by the development teams for Java SE 5.0 is 1.5.0.


### Why version?
The main aims are that:
- Everyone should know what features are available in the version of the app they have
- Everyone should know what version of the app they have if they are reporting bugs or requesting support

When I say everyone, I mean anyone who uses your app, including internal testers, beta testers and end users.



### Versioning Schemas

1 - Build Number Versioning <br />



2 - Commit Hashes /Git Short Hash, Git Commit Hash/ Versioning <br />
I’ve seen apps that use the last commit hash on a branch to identify test releases of an app. This uniquely identifies the release, but gives you no information about the order in which the releases occurred. For example if you have a feature that was added in version 1.3.4 and you have version 1.4.1, you know it is included. However if it was added in version 9a10ea01, you have absolutely no idea if it should be available or not in version 13be2fc4.



3 - Calendar /CalVer/ Versioning <br />


4 - Semantic /SemVer/ Versioning <br />


5 - Random /System Native/ Versioning <br />


6 - Milestones /Marketing/ Versioning <br />


7 - Geeky /Silly/ Versioning <br />


8 - explicit-versioning /CMS Versioning (CMSver)/       -          A versioning system for PordPress, Joomla and Drupal




 Automate versioning and CHANGELOG generation


- Geeky /Silly ?/ Versioning           :-     '4.2' being SUSE's initial release 

- Commit Hash /Git Short Hash, Git Commit Hash/ Versioning        :- the Git short hash is entirely silly. I have included it in versions for internal micro-services that deploy frequently to end the conversation about, "how do I go back to the deployed service's source code." In practice no one ever really needs to do this but also, in practice, people do all sorts of nasty things in their SCM to support this that are entirely unnecessary if the hash is present in the artifact's version.



I agree. SemVer natters mostly to technical users using an application. If, as you mentioned, it is a microservice, using build numbers or commit hashes is just as good and easier to do. Still, if that microservice is a dependency of apps developed by other teams, then those other teams are technical users of it and they might benefit from SemVer. For example, they might make decisions whether to use a newer version of the API of that microservice depending on whether it is a major or a minor change.




Semantic Versioning, or semver for short, is one of those systems that's used all the time by JavaScript or Ruby developers 


I use a combination of semantic and calendar versioning. 

1.2.3-20210523

Each will work for it self, but I like to see braking changes and like to know how old the version is.

It's normal and quite common to add a suffix to semantic versions. I do that all the time, sometimes with CalVer as a suffix, and, at others, with commit hashes.

-----------------------------------------------------------------------

### Versioning for mobile apps
As you probably already know, both the Play Store and the App Store (hereafter referred to as “the stores”) won’t let you upload a version of your app that has a lower version number than what is already on their server. The stores will only offer the latest version of your app for download, or update. So uploading a lower version of your app wouldn’t work because nobody would ever get it installed anyway.

All of our telemetry to do with our app, like the data that Crashlytics or Sentry.io sends us will be attached to a certain version of the app. So if we don’t put a lot of thought into the versioning process, we could potentially be left puzzled if we start receiving crashes or errors for a certain version of our app.

-------------------------

#### Android Versioning
On Android, we have our versionCode, and our versionName (as per the documentation). Let’s take a better look at what these represent.
https://developer.android.com/studio/publish/versioning#appversioning

**versionName**
versionName is just a text based representation of the version of your app. Its sole purpose it to be shown to the user to identify the version of the app in a way that the user could perhaps understand. So you can set this to literally anything that you want. Of course, you should set it to something that means something to you, as this version name will be attached to any telemetry that comes from your app (like crashes, for example). We’ll look at what some good ideas would be for this field a little later on, after we’ve seen how iOS handles versions.

**versionCode**
versionCode is the internal version of our application, and only supports integer values. Every time we release our app, we’re supposed to increment this number, whether our release is major or minor. We can’t define major, minor, or patch levels in this version code, and it can only be an integer. This is sometimes called build number.

The maximum version code you can have is 2100000000. You might think it’s weird to call this out, and that it’s pretty unlikely that you would ever come close to releasing two billion, one hundred million versions of your app. But the real reason why I call this out is because sometimes you can be right at the end of uploading your app, only to have the Play Store knock it back citing an issue with the version you’ve chosen. In that moment, you can be tempted to just throw in a really high number, like 1000. Then, next time, you put in an even higher number like 10,000, and so on and so forth. This is always the wrong thing to do. If you’ve started down this path, work out your current version, and a way to update it incrementally.

So, what should my versionName and versionCode be?
Your versionCode should just increment every time you release your app, and your versionName should be something that makes sense to you and your users, such as a {major}.{minor}.{patch} versioning scheme.


In android it is set in the versionName field in the gradle file.
https://miro.medium.com/max/1400/1*kDof-Q6E35aueo6Fov6Gnw.png


<br />


#### iOS Versioning
On iOS, we haveCFBundleShortVersionString (Release Version Number) and CFBundleVersion (Build Version Number). The relationship between these two properties are explained in Apple’s (slightly outdated, but still relevant) note on . Let’s take a more detailed look at these two properties.

https://developer.apple.com/library/archive/technotes/tn2420/_index.html

**CFBundleShortVersionString (Release Version Number)**
 is the external user facing release version of your app displayed in the App Store. It must follow the {major}.{minor}.{patch} version format of three period separated integers. This must be incremented every time you release a version to the App Store.

**CFBundleVersion (Build Version Number)**
 is the internal build version number of your application used for testing and development. It appears in {major}.{minor}.{patch} format of one to three period separated integers. If {minor}.{patch} are not provided, then they will default to zero. For example, if you specify ‘10’, then your build version will be ‘10.0.0’. Build version number must be incremented with every release candidate submitted to test flight for a particular release version number. For iOS apps, build version number can be reused across different release version numbers. The same cannot be said about MacOS apps, which must have a unique build version number accross all release version numbers.

Why would we want different internal build and external release version numbers? This might be a little confusing. Well, your internal version might increment quite frequently with many subsequent submissions to Test Flight for the same release version. This could be because of bugs found from a round of QA or dealing with the issues of App store submission rejections. Your release build number only changes after successful submissions to the App Store.

Now, maybe you’re there, up to this part of this article, completely bored out of your mind and thinking to yourself “Whatever, I’ll just submit whatever version number I want, and if the store accepts it then it’s all good”. Well, technically you can, and some people have, but you might break in-app purchases for your app. Yes, really, as per the documentation.
https://developer.apple.com/library/archive/technotes/tn2413/_index.html#//apple_ref/doc/uid/DTS40016228-CH1-TROUBLESHOOTING-CALLING_THE_PAYMENT_QUEUE___S_RESTORECOMPLETEDTRANSACTIONS_METHOD_DOES_NOT_RESTORE_ANY_PRODUCTS_IN_MY_APPLICATION


In iOS it is set in the Version field in the General tab of your app’s target properties.

https://miro.medium.com/max/1400/1*xJtZktBlCBFDkgUqWpw9qQ.png


-----------------------------------------------------------------------

**NOTE:**
A note on build numbers / version codes
As well as a version number, iOS apps have a build number, and Android apps have an equivalent version code. This is a single number that identifies a particular build, and the app stores require that it must always be higher than the last one when you submit a build. They don’t have a special purpose in my workflow, so we simply increment them at the same time as the version number.


**Backward compatibility**
Moving your logic to the servers makes sense, but you still need a structured way to support your old apps.
The server needs to know how to handle each request, because sometimes the version of the app dictates slightly different response.

A good practice would be to include some meta data in every API call; something like the OS type, the app version and the user ID (and whatever makes sense for your product).
The server gets the request with the meta data and if needed - can split the function logic into relevant chunks as required by the business, or as required to support older versions of the app.


**Force upgrade** 
There are times when the above techniques will not work or will not make sense (effort wise).
In such cases you better have an option to force your users to upgrade the app.
The easiest way is to have a simple API method that is being called every time the app starts. The client reports his version number to the server and if it’s below a certain number (meaning it’s too old) - the server returns an “upgrade required” error which is presented to the user blocking him from continuing until he clicks on the “upgrade now” button.


-----------------------------------------------------------------------


<br />

### Automating Versioning
Having a semantically versioned software will help developers easily maintain and communicate changes in a software. Even after manually merging the PR, tagging the commit, and pushing the release, developers have to write release notes. There are a lot of different steps, and many are repetitive and take time. As such to make versioning and the other repetitive tasks more efficiently flow, we have to completely automate our release process. 

To make sure that we are releasing the correct version — by correctly incrementing the semantic version number — we need to standardize our commit messages. By having a standardized format for commit messages, we can know when to increment which number and easily generate a release note. As such we are going to be using "Conventional Commits".

<br />

#### Conventional Commits
Is a specification that is a lightweight convention on top of commit messages. It provides an easy set of rules for creating an explicit commit history; which makes it easier to write automated tools on top of. This convention helps in automating versioning using SemVer convention, by describing the features, fixes, and breaking changes made in commit messages.

The commit message should be structured as follows, each commit message consists of a type, a description, a scope(optional), a body(optional) and footer(s)(optional):-
```
<type>[optional scope]: <description>

[optional body]

[optional footer(s)]
```

Here is the site for more:
https://www.conventionalcommits.org

<br />

#### Semantic Versioning (also called SemVer)
Is a formal convention for determining the version number of new software releases. The standard helps software users to understand the severity of changes in each new distribution. A project that uses semantic versioning will advertise a Major, Minor and Patch number for each release.

Major - breaking changes / changes in functionality
Minor - new features or major bug fixes have been added
Patch - hotfix / Revision / Upgrade

Build - ? - Buildnumber should be autogenerated from a build script. (The build, packaging & publishing is fully automated)

```
 alpha
 beta
 RC (release candidate)
 GA (general availability)

0.1.0
0.1.1
0.1.2
```

Here is the site for more:
https://semver.org

<br />

## Specification
Here are the 4 tools of choice for automating versioning:

| Programs | Links |
| --- | --- |
| Semantic Release | https://github.com/semantic-release/semantic-release |
| Standard Version | https://github.com/conventional-changelog/standard-version |
| Release It! | https://github.com/release-it/release-it |
| Versionize | https://github.com/versionize/versionize |


GitVersion ??? - You can use something like  to help set a semantic version automatically for your app.
https://github.com/GitTools/GitVersion


They are a fully automated version management (Automatic versioning | CHANGELOG generation | package publishing) softwares that automatically version our software with "Semantic Versions" based on our Git commit messages. For this automation to work the commits must adhere to the standard "Conventional Commits". This program will use the commit messages to determine the consumer impact of changes in the codebase. Following formalized conventions for commit messages, automatically determines the next semantic version number, generates a changelog and publishes the release. <br />

<br />

**Here is a guide for setting up version automation for java projects:** <br /> "Supercharge your Java Projects with Conventional Commits, Semantic Versioning and Semantic Releases" <br />
https://dwmkerr.com/conventional-commits-and-semantic-versioning-for-java/

<br />

## Security Concerns
Security Concern 1: <br />
...
